{"mappings":"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","sources":["<anon>","src/scrubImageSequence.js"],"sourcesContent":["(() => {\n// Global device width for media queries (canvas sizing now comes from the parent element)\nconst $c8fe6ad741db8e1e$var$viewportWidth = document.documentElement.clientWidth;\nconst $c8fe6ad741db8e1e$var$mm = gsap.matchMedia();\n// Global counters for overall image loading progress (if needed for a loading indicator)\nlet $c8fe6ad741db8e1e$var$globalImagesRemaining = 0;\nlet $c8fe6ad741db8e1e$var$totalImagesCount = 0;\n// Initialize sections by finding all elements with [scrub-wrapper]\nfunction $c8fe6ad741db8e1e$var$initSections() {\n    const sections = gsap.utils.toArray(\"[scrub-wrapper]\");\n    sections.forEach((section)=>{\n        const prefix = section.dataset.prefix;\n        const suffix = section.dataset.suffix;\n        const frames = Number(section.dataset.framecount);\n        const canvas = section.querySelector(\"canvas\");\n        if (!canvas || !prefix || !suffix || !frames) return;\n        const device = $c8fe6ad741db8e1e$var$viewportWidth >= 768 ? \"desktop\" : \"mobile\";\n        $c8fe6ad741db8e1e$var$totalImagesCount += frames;\n        $c8fe6ad741db8e1e$var$globalImagesRemaining += frames;\n        $c8fe6ad741db8e1e$var$initCanvas(section, canvas, prefix, suffix, frames, device);\n    });\n}\n// Update the global loading counter and call lenis.resize when all images have loaded.\nfunction $c8fe6ad741db8e1e$var$updateGlobalImageCount() {\n    $c8fe6ad741db8e1e$var$globalImagesRemaining--;\n    const updatedPercent = 100 - Math.round($c8fe6ad741db8e1e$var$globalImagesRemaining * 100 / $c8fe6ad741db8e1e$var$totalImagesCount);\n    // Optionally, use updatedPercent to update a loading bar.\n    if ($c8fe6ad741db8e1e$var$globalImagesRemaining === 0) setTimeout(()=>{\n        lenis.resize();\n    }, 500);\n}\n// Initialize the canvas for a given section.\n// Canvas dimensions are derived from its parent element.\nfunction $c8fe6ad741db8e1e$var$initCanvas(section, canvas, prefix, suffix, frames, device) {\n    const context = canvas.getContext(\"2d\");\n    const parent = canvas.parentElement;\n    canvas.width = parent.clientWidth;\n    canvas.height = parent.clientHeight;\n    const frameCount = frames;\n    const currentFrame = (index)=>`${prefix}${device}/${(index + 1).toString().padStart(3, \"0\")}${suffix}`;\n    const images = [];\n    let imagesLoaded = 0;\n    for(let i = 0; i < frameCount; i++){\n        const img = new Image();\n        const imgSrc = currentFrame(i);\n        img.onload = ()=>{\n            imagesLoaded++;\n            $c8fe6ad741db8e1e$var$updateGlobalImageCount();\n            // Immediately render the first frame as soon as it loads.\n            if (i === 0) $c8fe6ad741db8e1e$var$render(images, {\n                frame: 0\n            }, context, canvas);\n            if (imagesLoaded === frameCount) $c8fe6ad741db8e1e$var$initCanvasAnimations(section, images, context, canvas);\n        };\n        img.onerror = ()=>{\n            imagesLoaded++;\n            $c8fe6ad741db8e1e$var$updateGlobalImageCount();\n            if (imagesLoaded === frameCount) $c8fe6ad741db8e1e$var$initCanvasAnimations(section, images, context, canvas);\n        };\n        img.src = imgSrc;\n        images.push(img);\n    }\n}\n// Initialize animations for each [frames-play] block in the section.\nfunction $c8fe6ad741db8e1e$var$initCanvasAnimations(section, images, context, canvas) {\n    // A default sequence used for an initial render.\n    const defaultSequence = {\n        frame: 0\n    };\n    const blocks = section.querySelectorAll(\"[frames-play]\");\n    blocks.forEach((block)=>{\n        const start = Number(block.dataset.start);\n        const end = Number(block.dataset.end);\n        // Total frames to animate in this block:\n        const blockFrameCount = end - start;\n        // Compute duration for 30fps playback (duration in seconds)\n        const duration = blockFrameCount / 30;\n        const blockSequence = {\n            frame: 0\n        };\n        // If the data-autoplay-sequence attribute is presentâ€¦\n        if (\"autoplaySequence\" in block.dataset) {\n            const delay = block.dataset.autoplayDelay ? Number(block.dataset.autoplayDelay) : 0;\n            if (window.scrollY <= 1) // If a delay is specified, wait before starting the autoplay tween.\n            gsap.to(blockSequence, {\n                frame: end - 1,\n                duration: duration,\n                ease: \"none\",\n                snap: \"frame\",\n                delay: delay,\n                onUpdate: ()=>$c8fe6ad741db8e1e$var$render(images, blockSequence, context, canvas)\n            });\n            else {\n                // If not at the top, immediately show the final frame.\n                blockSequence.frame = end - 1;\n                $c8fe6ad741db8e1e$var$render(images, blockSequence, context, canvas);\n            }\n        } else // For blocks without autoplay, use the standard scroll-triggered timeline.\n        gsap.timeline({\n            onUpdate: ()=>$c8fe6ad741db8e1e$var$render(images, blockSequence, context, canvas),\n            scrollTrigger: {\n                trigger: block,\n                pin: false,\n                scrub: 1,\n                start: block.dataset.startPos || \"top top\",\n                end: block.dataset.endPos || \"bottom bottom\",\n                markers: false\n            }\n        }).fromTo(blockSequence, {\n            frame: start - 1\n        }, {\n            frame: end - 1,\n            snap: \"frame\",\n            ease: \"none\",\n            duration: 1\n        }, 0);\n    });\n    // Render the default sequence initially.\n    $c8fe6ad741db8e1e$var$render(images, defaultSequence, context, canvas);\n    // On window resize, update canvas dimensions using the parent's size.\n    window.addEventListener(\"resize\", ()=>{\n        const parent = canvas.parentElement;\n        canvas.width = parent.clientWidth;\n        canvas.height = parent.clientHeight;\n        $c8fe6ad741db8e1e$var$render(images, defaultSequence, context, canvas);\n    });\n}\n// Render the current frame to the canvas.\nfunction $c8fe6ad741db8e1e$var$render(images, sequence, context, canvas) {\n    const img = images[sequence.frame];\n    context.clearRect(0, 0, canvas.width, canvas.height);\n    // Compute scale factor so the image covers the canvas while preserving aspect ratio.\n    const scaleFactor = Math.max(canvas.width / img.width, canvas.height / img.height);\n    const newWidth = img.width * scaleFactor;\n    const newHeight = img.height * scaleFactor;\n    const x = canvas.width / 2 - newWidth / 2;\n    const y = canvas.height / 2 - newHeight / 2;\n    context.drawImage(img, x, y, newWidth, newHeight);\n}\n// Initialize sections based on media queries.\n$c8fe6ad741db8e1e$var$mm.add(\"(min-width: 768px)\", ()=>{\n    $c8fe6ad741db8e1e$var$initSections();\n});\n$c8fe6ad741db8e1e$var$mm.add(\"(max-width: 767px)\", ()=>{\n    $c8fe6ad741db8e1e$var$initSections();\n});\n\n})();\n//# sourceMappingURL=scrubImageSequence.js.map\n","// Global device width for media queries (canvas sizing now comes from the parent element)\nconst viewportWidth = document.documentElement.clientWidth;\nconst mm = gsap.matchMedia();\n\n// Global counters for overall image loading progress (if needed for a loading indicator)\nlet globalImagesRemaining = 0;\nlet totalImagesCount = 0;\n\n// Initialize sections by finding all elements with [scrub-wrapper]\nfunction initSections() {\n  const sections = gsap.utils.toArray(\"[scrub-wrapper]\");\n  sections.forEach((section) => {\n    const prefix = section.dataset.prefix;\n    const suffix = section.dataset.suffix;\n    const frames = Number(section.dataset.framecount);\n    const canvas = section.querySelector(\"canvas\");\n    if (!canvas || !prefix || !suffix || !frames) return;\n\n    const device = viewportWidth >= 768 ? \"desktop\" : \"mobile\";\n\n    totalImagesCount += frames;\n    globalImagesRemaining += frames;\n    initCanvas(section, canvas, prefix, suffix, frames, device);\n  });\n}\n\n// Update the global loading counter and call lenis.resize when all images have loaded.\nfunction updateGlobalImageCount() {\n  globalImagesRemaining--;\n  const updatedPercent =\n    100 - Math.round((globalImagesRemaining * 100) / totalImagesCount);\n  // Optionally, use updatedPercent to update a loading bar.\n  if (globalImagesRemaining === 0) {\n    setTimeout(() => {\n      lenis.resize();\n    }, 500);\n  }\n}\n\n// Initialize the canvas for a given section.\n// Canvas dimensions are derived from its parent element.\nfunction initCanvas(section, canvas, prefix, suffix, frames, device) {\n  const context = canvas.getContext(\"2d\");\n  const parent = canvas.parentElement;\n  canvas.width = parent.clientWidth;\n  canvas.height = parent.clientHeight;\n\n  const frameCount = frames;\n  const currentFrame = (index) =>\n    `${prefix}${device}/${(index + 1).toString().padStart(3, \"0\")}${suffix}`;\n  const images = [];\n  let imagesLoaded = 0;\n\n  for (let i = 0; i < frameCount; i++) {\n    const img = new Image();\n    const imgSrc = currentFrame(i);\n    img.onload = () => {\n      imagesLoaded++;\n      updateGlobalImageCount();\n      // Immediately render the first frame as soon as it loads.\n      if (i === 0) {\n        render(images, { frame: 0 }, context, canvas);\n      }\n      if (imagesLoaded === frameCount) {\n        initCanvasAnimations(section, images, context, canvas);\n      }\n    };\n    img.onerror = () => {\n      imagesLoaded++;\n      updateGlobalImageCount();\n      if (imagesLoaded === frameCount) {\n        initCanvasAnimations(section, images, context, canvas);\n      }\n    };\n    img.src = imgSrc;\n    images.push(img);\n  }\n}\n\n// Initialize animations for each [frames-play] block in the section.\nfunction initCanvasAnimations(section, images, context, canvas) {\n  // A default sequence used for an initial render.\n  const defaultSequence = { frame: 0 };\n\n  const blocks = section.querySelectorAll(\"[frames-play]\");\n  blocks.forEach((block) => {\n    const start = Number(block.dataset.start);\n    const end = Number(block.dataset.end);\n    // Total frames to animate in this block:\n    const blockFrameCount = end - start;\n    // Compute duration for 30fps playback (duration in seconds)\n    const duration = blockFrameCount / 30;\n    const blockSequence = { frame: 0 };\n\n    // If the data-autoplay-sequence attribute is presentâ€¦\n    if (\"autoplaySequence\" in block.dataset) {\n      const delay = block.dataset.autoplayDelay\n        ? Number(block.dataset.autoplayDelay)\n        : 0;\n      \n      if (window.scrollY <= 1) {\n        // If a delay is specified, wait before starting the autoplay tween.\n        gsap.to(blockSequence, {\n          frame: end - 1,\n          duration: duration,\n          ease: \"none\",\n          snap: \"frame\",\n          delay,\n          onUpdate: () => render(images, blockSequence, context, canvas),\n        });\n      } else {\n        // If not at the top, immediately show the final frame.\n        blockSequence.frame = end - 1;\n        render(images, blockSequence, context, canvas);\n      }\n    } else {\n      // For blocks without autoplay, use the standard scroll-triggered timeline.\n      gsap\n        .timeline({\n          onUpdate: () => render(images, blockSequence, context, canvas),\n          scrollTrigger: {\n            trigger: block,\n            pin: false,\n            scrub: 1,\n            start: block.dataset.startPos || \"top top\",\n            end: block.dataset.endPos || \"bottom bottom\",\n            markers: false,\n          },\n        })\n        .fromTo(\n          blockSequence,\n          { frame: start - 1 },\n          { frame: end - 1, snap: \"frame\", ease: \"none\", duration: 1 },\n          0\n        );\n    }\n  });\n\n  // Render the default sequence initially.\n  render(images, defaultSequence, context, canvas);\n\n  // On window resize, update canvas dimensions using the parent's size.\n  window.addEventListener(\"resize\", () => {\n    const parent = canvas.parentElement;\n    canvas.width = parent.clientWidth;\n    canvas.height = parent.clientHeight;\n    render(images, defaultSequence, context, canvas);\n  });\n}\n\n// Render the current frame to the canvas.\nfunction render(images, sequence, context, canvas) {\n  const img = images[sequence.frame];\n  context.clearRect(0, 0, canvas.width, canvas.height);\n\n  // Compute scale factor so the image covers the canvas while preserving aspect ratio.\n  const scaleFactor = Math.max(\n    canvas.width / img.width,\n    canvas.height / img.height\n  );\n  const newWidth = img.width * scaleFactor;\n  const newHeight = img.height * scaleFactor;\n  const x = canvas.width / 2 - newWidth / 2;\n  const y = canvas.height / 2 - newHeight / 2;\n\n  context.drawImage(img, x, y, newWidth, newHeight);\n}\n\n// Initialize sections based on media queries.\nmm.add(\"(min-width: 768px)\", () => {\n  initSections();\n});\nmm.add(\"(max-width: 767px)\", () => {\n  initSections();\n});\n"],"names":["$c8fe6ad741db8e1e$var$viewportWidth","document","documentElement","clientWidth","$c8fe6ad741db8e1e$var$mm","gsap","matchMedia","$c8fe6ad741db8e1e$var$globalImagesRemaining","$c8fe6ad741db8e1e$var$totalImagesCount","$c8fe6ad741db8e1e$var$initSections","sections","utils","toArray","forEach","section","prefix","dataset","suffix","frames","Number","framecount","canvas","querySelector","$c8fe6ad741db8e1e$var$initCanvas","device","context","getContext","parent","parentElement","width","height","clientHeight","currentFrame","index","toString","padStart","images","imagesLoaded","i","img","Image","imgSrc","onload","$c8fe6ad741db8e1e$var$updateGlobalImageCount","$c8fe6ad741db8e1e$var$render","frame","$c8fe6ad741db8e1e$var$initCanvasAnimations","onerror","src","push","setTimeout","lenis","resize","defaultSequence","blocks","querySelectorAll","block","start","end","blockSequence","delay","autoplayDelay","window","scrollY","to","duration","blockFrameCount","ease","snap","onUpdate","timeline","scrollTrigger","trigger","pin","scrub","startPos","endPos","markers","fromTo","addEventListener","sequence","clearRect","scaleFactor","Math","max","newWidth","newHeight","x","y","drawImage","add"],"version":3,"file":"scrubImageSequence.js.map"}