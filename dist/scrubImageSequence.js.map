{"mappings":"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","sources":["<anon>","src/scrubImageSequence.js"],"sourcesContent":["(() => {\n// Global dimensions\nconst $c8fe6ad741db8e1e$var$width = document.documentElement.clientWidth;\nconst $c8fe6ad741db8e1e$var$height = window.innerHeight;\n// Media queries (kept as in your original code)\nconst $c8fe6ad741db8e1e$var$mm = gsap.matchMedia();\n// Global counters (if you want to track overall loading progress)\nlet $c8fe6ad741db8e1e$var$globalImagesRemaining = 0;\nlet $c8fe6ad741db8e1e$var$totalImagesCount = 0;\n// Initialize sections – now each section will update global counts\nfunction $c8fe6ad741db8e1e$var$initSections() {\n    const sections = gsap.utils.toArray(\"[scrub-wrapper]\");\n    sections.forEach((section)=>{\n        const prefix = section.dataset.prefix;\n        const suffix = section.dataset.suffix;\n        const frames = Number(section.dataset.framecount);\n        const canvas = section.querySelector(\"canvas\");\n        if (!canvas || !prefix || !suffix || !frames) return;\n        // Device check remains the same\n        const device = $c8fe6ad741db8e1e$var$width >= 768 ? \"desktop\" : \"mobile\";\n        $c8fe6ad741db8e1e$var$totalImagesCount += frames;\n        $c8fe6ad741db8e1e$var$globalImagesRemaining += frames;\n        $c8fe6ad741db8e1e$var$initCanvas(section, canvas, prefix, suffix, frames, device);\n    });\n}\n// Update global counter and call lenis.resize when all images are loaded\nfunction $c8fe6ad741db8e1e$var$updateGlobalImageCount() {\n    $c8fe6ad741db8e1e$var$globalImagesRemaining--;\n    const updatedPercent = 100 - Math.round($c8fe6ad741db8e1e$var$globalImagesRemaining * 100 / $c8fe6ad741db8e1e$var$totalImagesCount);\n    // You can use updatedPercent for a loading bar if needed\n    if ($c8fe6ad741db8e1e$var$globalImagesRemaining === 0) setTimeout(()=>{\n        lenis.resize();\n    }, 500);\n}\n// Initialize the canvas for a given section.\n// Refactored to use a local \"imagesLoaded\" counter so that each section handles its own images.\nfunction $c8fe6ad741db8e1e$var$initCanvas(section, canvas, prefix, suffix, frames, device) {\n    const context = canvas.getContext(\"2d\");\n    canvas.width = document.documentElement.clientWidth;\n    canvas.height = window.innerHeight;\n    const frameCount = frames;\n    const currentFrame = (index)=>`${prefix}${device}/${(index + 1).toString().padStart(3, \"0\")}${suffix}`;\n    const images = [];\n    let imagesLoaded = 0;\n    for(let i = 0; i < frameCount; i++){\n        const img = new Image();\n        const imgSrc = currentFrame(i);\n        img.onload = ()=>{\n            imagesLoaded++;\n            $c8fe6ad741db8e1e$var$updateGlobalImageCount();\n            if (imagesLoaded === frameCount) // When all images for this section are loaded, initialize animations.\n            $c8fe6ad741db8e1e$var$initCanvasAnimations(section, images, context, canvas);\n        };\n        img.onerror = ()=>{\n            imagesLoaded++;\n            $c8fe6ad741db8e1e$var$updateGlobalImageCount();\n            if (imagesLoaded === frameCount) $c8fe6ad741db8e1e$var$initCanvasAnimations(section, images, context, canvas);\n        };\n        img.src = imgSrc;\n        images.push(img);\n    }\n}\n// Sets up the animation for the canvas.\n// For each block (with [frames-play]), we check for a data-autoplay-sequence attribute.\n// • If present and if the page scroll is at the top (<=1px), we auto-animate the image sequence.\n// • Otherwise, we immediately render the final frame of that block.\n// Blocks without the attribute use the standard ScrollTrigger timeline.\nfunction $c8fe6ad741db8e1e$var$initCanvasAnimations(section, images, context, canvas) {\n    // This default sequence is used for an initial render (it’s independent of any block)\n    const defaultSequence = {\n        frame: 0\n    };\n    const blocks = section.querySelectorAll(\"[frames-play]\");\n    blocks.forEach((block)=>{\n        const start = Number(block.dataset.start);\n        const end = Number(block.dataset.end);\n        const posStart = block.dataset.startPos || \"top top\";\n        const posEnd = block.dataset.endPos || \"bottom bottom\";\n        const blockSequence = {\n            frame: 0\n        };\n        // Check if we want to auto-play this block’s sequence:\n        if (\"autoplaySequence\" in block.dataset) {\n            if (window.scrollY <= 1) // Animate automatically from start to end\n            gsap.to(blockSequence, {\n                frame: end - 1,\n                duration: 1,\n                ease: \"none\",\n                onUpdate: ()=>$c8fe6ad741db8e1e$var$render(images, blockSequence, context, canvas)\n            });\n            else {\n                // If the scroll is already past the top, set it to the final frame\n                blockSequence.frame = end - 1;\n                $c8fe6ad741db8e1e$var$render(images, blockSequence, context, canvas);\n            }\n        } else // Standard scroll-triggered timeline for this block\n        gsap.timeline({\n            onUpdate: ()=>$c8fe6ad741db8e1e$var$render(images, blockSequence, context, canvas),\n            scrollTrigger: {\n                trigger: block,\n                pin: false,\n                scrub: 1,\n                start: posStart,\n                end: posEnd,\n                markers: false\n            }\n        }).fromTo(blockSequence, {\n            frame: start - 1\n        }, {\n            frame: end - 1,\n            snap: \"frame\",\n            ease: \"none\",\n            duration: 1\n        }, 0);\n    });\n    // Render the default sequence initially\n    $c8fe6ad741db8e1e$var$render(images, defaultSequence, context, canvas);\n    // Update canvas dimensions and re-render on window resize\n    window.addEventListener(\"resize\", ()=>{\n        canvas.width = document.documentElement.clientWidth;\n        canvas.height = window.innerHeight;\n        $c8fe6ad741db8e1e$var$render(images, defaultSequence, context, canvas);\n    });\n}\n// Renders the current image on the canvas based on the sequence's frame value.\nfunction $c8fe6ad741db8e1e$var$render(images, sequence, context, canvas) {\n    const img = images[sequence.frame];\n    context.clearRect(0, 0, canvas.width, canvas.height);\n    // Calculate scale factor so the image covers the canvas\n    const scaleFactor = Math.max(canvas.width / img.width, canvas.height / img.height);\n    const newWidth = img.width * scaleFactor;\n    const newHeight = img.height * scaleFactor;\n    const x = canvas.width / 2 - newWidth / 2;\n    const y = canvas.height / 2 - newHeight / 2;\n    context.drawImage(img, x, y, newWidth, newHeight);\n}\n// Initialize sections based on media queries\n$c8fe6ad741db8e1e$var$mm.add(\"(min-width: 768px)\", ()=>{\n    $c8fe6ad741db8e1e$var$initSections();\n});\n$c8fe6ad741db8e1e$var$mm.add(\"(max-width: 767px)\", ()=>{\n    $c8fe6ad741db8e1e$var$initSections();\n});\n\n})();\n//# sourceMappingURL=scrubImageSequence.js.map\n","// Global dimensions\nconst width = document.documentElement.clientWidth;\nconst height = window.innerHeight;\n\n// Media queries (kept as in your original code)\nconst mm = gsap.matchMedia();\n\n// Global counters (if you want to track overall loading progress)\nlet globalImagesRemaining = 0;\nlet totalImagesCount = 0;\n\n// Initialize sections – now each section will update global counts\nfunction initSections() {\n  const sections = gsap.utils.toArray(\"[scrub-wrapper]\");\n  sections.forEach((section) => {\n    const prefix = section.dataset.prefix;\n    const suffix = section.dataset.suffix;\n    const frames = Number(section.dataset.framecount);\n    const canvas = section.querySelector(\"canvas\");\n    if (!canvas || !prefix || !suffix || !frames) return;\n\n    // Device check remains the same\n    const device = width >= 768 ? \"desktop\" : \"mobile\";\n\n    totalImagesCount += frames;\n    globalImagesRemaining += frames;\n    initCanvas(section, canvas, prefix, suffix, frames, device);\n  });\n}\n\n// Update global counter and call lenis.resize when all images are loaded\nfunction updateGlobalImageCount() {\n  globalImagesRemaining--;\n  const updatedPercent =\n    100 - Math.round((globalImagesRemaining * 100) / totalImagesCount);\n  // You can use updatedPercent for a loading bar if needed\n  if (globalImagesRemaining === 0) {\n    setTimeout(() => {\n      lenis.resize();\n    }, 500);\n  }\n}\n\n// Initialize the canvas for a given section.\n// Refactored to use a local \"imagesLoaded\" counter so that each section handles its own images.\nfunction initCanvas(section, canvas, prefix, suffix, frames, device) {\n  const context = canvas.getContext(\"2d\");\n  canvas.width = document.documentElement.clientWidth;\n  canvas.height = window.innerHeight;\n\n  const frameCount = frames;\n  const currentFrame = (index) =>\n    `${prefix}${device}/${(index + 1).toString().padStart(3, \"0\")}${suffix}`;\n  const images = [];\n  let imagesLoaded = 0;\n\n  for (let i = 0; i < frameCount; i++) {\n    const img = new Image();\n    const imgSrc = currentFrame(i);\n    img.onload = () => {\n      imagesLoaded++;\n      updateGlobalImageCount();\n      if (imagesLoaded === frameCount) {\n        // When all images for this section are loaded, initialize animations.\n        initCanvasAnimations(section, images, context, canvas);\n      }\n    };\n    img.onerror = () => {\n      imagesLoaded++;\n      updateGlobalImageCount();\n      if (imagesLoaded === frameCount) {\n        initCanvasAnimations(section, images, context, canvas);\n      }\n    };\n    img.src = imgSrc;\n    images.push(img);\n  }\n}\n\n// Sets up the animation for the canvas.\n// For each block (with [frames-play]), we check for a data-autoplay-sequence attribute.\n// • If present and if the page scroll is at the top (<=1px), we auto-animate the image sequence.\n// • Otherwise, we immediately render the final frame of that block.\n// Blocks without the attribute use the standard ScrollTrigger timeline.\nfunction initCanvasAnimations(section, images, context, canvas) {\n  // This default sequence is used for an initial render (it’s independent of any block)\n  const defaultSequence = { frame: 0 };\n\n  const blocks = section.querySelectorAll(\"[frames-play]\");\n  blocks.forEach((block) => {\n    const start = Number(block.dataset.start);\n    const end = Number(block.dataset.end);\n    const posStart = block.dataset.startPos || \"top top\";\n    const posEnd = block.dataset.endPos || \"bottom bottom\";\n    const blockSequence = { frame: 0 };\n\n    // Check if we want to auto-play this block’s sequence:\n    if (\"autoplaySequence\" in block.dataset) {\n      if (window.scrollY <= 1) {\n        // Animate automatically from start to end\n        gsap.to(blockSequence, {\n          frame: end - 1,\n          duration: 1,\n          ease: \"none\",\n          onUpdate: () => render(images, blockSequence, context, canvas),\n        });\n      } else {\n        // If the scroll is already past the top, set it to the final frame\n        blockSequence.frame = end - 1;\n        render(images, blockSequence, context, canvas);\n      }\n    } else {\n      // Standard scroll-triggered timeline for this block\n      gsap\n        .timeline({\n          onUpdate: () => render(images, blockSequence, context, canvas),\n          scrollTrigger: {\n            trigger: block,\n            pin: false,\n            scrub: 1,\n            start: posStart,\n            end: posEnd,\n            markers: false,\n          },\n        })\n        .fromTo(\n          blockSequence,\n          { frame: start - 1 },\n          { frame: end - 1, snap: \"frame\", ease: \"none\", duration: 1 },\n          0\n        );\n    }\n  });\n\n  // Render the default sequence initially\n  render(images, defaultSequence, context, canvas);\n\n  // Update canvas dimensions and re-render on window resize\n  window.addEventListener(\"resize\", () => {\n    canvas.width = document.documentElement.clientWidth;\n    canvas.height = window.innerHeight;\n    render(images, defaultSequence, context, canvas);\n  });\n}\n\n// Renders the current image on the canvas based on the sequence's frame value.\nfunction render(images, sequence, context, canvas) {\n  const img = images[sequence.frame];\n  context.clearRect(0, 0, canvas.width, canvas.height);\n\n  // Calculate scale factor so the image covers the canvas\n  const scaleFactor = Math.max(\n    canvas.width / img.width,\n    canvas.height / img.height\n  );\n  const newWidth = img.width * scaleFactor;\n  const newHeight = img.height * scaleFactor;\n  const x = canvas.width / 2 - newWidth / 2;\n  const y = canvas.height / 2 - newHeight / 2;\n\n  context.drawImage(img, x, y, newWidth, newHeight);\n}\n\n// Initialize sections based on media queries\nmm.add(\"(min-width: 768px)\", () => {\n  initSections();\n});\nmm.add(\"(max-width: 767px)\", () => {\n  initSections();\n});\n"],"names":["$c8fe6ad741db8e1e$var$width","document","documentElement","clientWidth","window","innerHeight","$c8fe6ad741db8e1e$var$mm","gsap","matchMedia","$c8fe6ad741db8e1e$var$globalImagesRemaining","$c8fe6ad741db8e1e$var$totalImagesCount","$c8fe6ad741db8e1e$var$initSections","sections","utils","toArray","forEach","section","prefix","dataset","suffix","frames","Number","framecount","canvas","querySelector","$c8fe6ad741db8e1e$var$initCanvas","device","context","getContext","width","height","currentFrame","index","toString","padStart","images","imagesLoaded","i","img","Image","imgSrc","onload","$c8fe6ad741db8e1e$var$updateGlobalImageCount","$c8fe6ad741db8e1e$var$initCanvasAnimations","onerror","src","push","setTimeout","lenis","resize","defaultSequence","frame","blocks","querySelectorAll","block","start","end","posStart","startPos","posEnd","endPos","blockSequence","scrollY","to","duration","ease","onUpdate","$c8fe6ad741db8e1e$var$render","timeline","scrollTrigger","trigger","pin","scrub","markers","fromTo","snap","addEventListener","sequence","clearRect","scaleFactor","Math","max","newWidth","newHeight","x","y","drawImage","add"],"version":3,"file":"scrubImageSequence.js.map"}